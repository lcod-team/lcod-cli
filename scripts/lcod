#!/usr/bin/env bash
set -eo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
COMMON_LIB="${SCRIPT_DIR}/lib/common.sh"

if [[ -n "${LCOD_COMMON_EMBEDDED:-}" ]]; then
  LCOD_EMBED_FILE=$(mktemp)
  printf '%s\n' "${LCOD_COMMON_EMBEDDED}" > "${LCOD_EMBED_FILE}"
  # shellcheck source=/dev/null
  source "${LCOD_EMBED_FILE}"
  cleanup_embedded_common() {
    rm -f "${LCOD_EMBED_FILE}"
  }
  trap 'cleanup_embedded_common' EXIT
elif [[ -f "${COMMON_LIB}" ]]; then
  # shellcheck source=lib/common.sh
  source "${COMMON_LIB}"
else
  echo "common library not found at ${COMMON_LIB}" >&2
  exit 1
fi

print_help() {
  cat <<'EOF'
Usage: lcod <command> [options]

Commands:
  version               Print the currently installed CLI version.
  kernel ls             List available kernels from the local manifest.
  kernel install <id>   Install or update a kernel (local path or release asset).
  kernel remove <id>    Remove a kernel from the manifest.
  kernel default <id>   Set the default kernel.
  run [options]         Execute the default kernel runtime with the given arguments.
  cache clean           Remove cached artefacts.
  self-update           Force immediate update check.
  help                  Show this message.

This is an early prototype. Most commands are placeholders until the backend scripts land.
EOF
}

resolve_kernel_repo() {
  local kernel_id="${1:?kernel id required}"
  case "${kernel_id}" in
    rs|rust)
      printf '%s' "${LCOD_RS_RELEASE_REPO:-lcod-team/lcod-kernel-rs}"
      ;;
    node|js)
      printf '%s' "${LCOD_NODE_RELEASE_REPO:-lcod-team/lcod-kernel-js}"
      ;;
    java|jvm)
      printf '%s' "${LCOD_JAVA_RELEASE_REPO:-lcod-team/lcod-kernel-java}"
      ;;
    *)
      return 1
      ;;
  esac
}

release_manifest_repo() {
  printf '%s' "${LCOD_RELEASE_MANIFEST_REPO:-lcod-team/lcod-release}"
}

manifest_cache_dir() {
  printf '%s' "${LCOD_CACHE_DIR}/manifests"
}

fetch_release_manifest() {
  local version="${1:?version required}"
  ensure_environment
  local cache_dir
  cache_dir="$(manifest_cache_dir)"
  mkdir -p "${cache_dir}"
  local manifest_path="${cache_dir}/release-${version}.json"
  if [[ -f "${manifest_path}" ]]; then
    printf '%s\n' "${manifest_path}"
    return 0
  fi

  local repo url tmp
  repo="$(release_manifest_repo)"
  url="https://github.com/${repo}/releases/download/v${version}/release-manifest.json"
  tmp="${manifest_path}.tmp"
  if download_file "${url}" "${tmp}"; then
    mv "${tmp}" "${manifest_path}"
    printf '%s\n' "${manifest_path}"
    return 0
  fi
  rm -f "${tmp}"
  return 1
}

manifest_resolve_asset_url() {
  local version="${1:?version required}"
  local kernel_key="${2:?kernel key required}"
  local asset_name="${3:?asset name required}"
  local manifest_path
  if ! manifest_path="$(fetch_release_manifest "${version}")"; then
    return 1
  fi
  MANIFEST_PATH="${manifest_path}" KERNEL_KEY="${kernel_key}" ASSET_NAME="${asset_name}" python3 <<'PY'
import json
import os
import sys

path = os.environ.get("MANIFEST_PATH")
kernel = os.environ.get("KERNEL_KEY")
asset_name = os.environ.get("ASSET_NAME")
if not path or not kernel or not asset_name:
    sys.exit(1)

try:
    with open(path, 'r', encoding='utf-8') as fh:
        data = json.load(fh)
except FileNotFoundError:
    sys.exit(1)

entry = data.get("kernels", {}).get(kernel)
if not entry:
    sys.exit(1)

for asset in entry.get("assets", []):
    if asset.get("name") == asset_name:
        url = asset.get("download_url")
        if url:
            print(url)
            sys.exit(0)

sys.exit(1)
PY
}

maybe_auto_update_cli() {
  if [[ "${LCOD_DISABLE_AUTO_UPDATE:-}" == "1" ]]; then
    return
  fi

  # Skip when running inside a repository checkout to avoid modifying tracked files
  if [[ -d "${ROOT_DIR}/.git" ]]; then
    return
  fi

  local interval
  interval=$(auto_update_interval)
  local now
  now=$(current_epoch)
  local last_check
  last_check=$(get_cli_last_check)
  if [[ -n "${interval}" && "${interval}" != "0" ]] && (( now - last_check < interval )); then
    return
  fi

  local cached_version
  cached_version=$(get_cli_cached_version)

  local script_path
  script_path=$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || printf '%s' "${BASH_SOURCE[0]}")

  if [[ ! -w "${script_path}" ]]; then
    write_cli_update_cache "${cached_version}" "${now}"
    return
  fi

  local remote_version
  if ! remote_version=$(fetch_latest_version "lcod-team/lcod-cli"); then
    write_cli_update_cache "${cached_version}" "${now}"
    return
  fi

  local tmp
  tmp=$(mktemp)
  local cli_url="${LCOD_CLI_SCRIPT_URL:-https://raw.githubusercontent.com/lcod-team/lcod-cli/main/dist/lcod}"
  if ! download_file "${cli_url}" "${tmp}"; then
    rm -f "${tmp}"
    write_cli_update_cache "${cached_version}" "${now}"
    return
  fi

  chmod +x "${tmp}"
  if mv "${tmp}" "${script_path}" 2>/dev/null; then
    cached_version="${remote_version}"
    log_info "CLI auto-updated to ${cached_version}."
    local lib_tmp
    lib_tmp=$(mktemp)
    local lib_url="${LCOD_CLI_LIB_URL:-https://raw.githubusercontent.com/lcod-team/lcod-cli/main/scripts/lib/common.sh}"
    if download_file "${lib_url}" "${lib_tmp}"; then
      mkdir -p "${SCRIPT_DIR}/lib"
      mv "${lib_tmp}" "${SCRIPT_DIR}/lib/common.sh"
    else
      rm -f "${lib_tmp}"
      log_warn "Failed to refresh CLI support library."
    fi
  else
    rm -f "${tmp}"
    log_warn "CLI auto-update failed (unable to write to ${script_path})."
  fi

  write_cli_update_cache "${cached_version}" "${now}"
}

auto_update_kernel_if_needed() {
  local kernel_id="${1:?kernel id required}"

  if [[ "${LCOD_DISABLE_AUTO_UPDATE:-}" == "1" ]]; then
    return
  fi

  local repo
  if ! repo=$(resolve_kernel_repo "${kernel_id}" 2>/dev/null); then
    return
  fi

  local interval
  interval=$(auto_update_interval)
  local now
  now=$(current_epoch)
  local last_check
  last_check=$(get_kernel_last_check "${kernel_id}")
  if [[ -n "${interval}" && "${interval}" != "0" ]] && (( now - last_check < interval )); then
    return
  fi

  local current_version
  current_version=$(jq -r --arg id "${kernel_id}" '.installedKernels[]? | select(.id == $id) | .version // ""' "${LCOD_CONFIG}")
  if [[ -z "${current_version}" ]]; then
    update_kernel_update_cache "${kernel_id}" "" "${now}"
    return
  fi

  local remote_version
  if ! remote_version=$(fetch_latest_runtime_version "${repo}"); then
    update_kernel_update_cache "${kernel_id}" "${current_version}" "${now}"
    return
  fi

  if [[ -n "${remote_version}" && "${remote_version}" != "${current_version}" ]]; then
    log_info "Auto-updating kernel '${kernel_id}' to ${remote_version}."
    if cmd_kernel_install "${kernel_id}" --from-release --version "${remote_version}" --force --repo "${repo}"; then
      current_version="${remote_version}"
    else
      log_warn "Auto-update failed for kernel '${kernel_id}'."
    fi
  fi

  update_kernel_update_cache "${kernel_id}" "${current_version}" "${now}"
}

detect_kernel_type() {
  local kernel_path="${1:?kernel path required}"
  local kernel_id="${2:-}"
  case "${kernel_id}" in
    node|js)
      printf '%s\n' "node"
      return
      ;;
    java|jvm)
      printf '%s\n' "java"
      return
      ;;
  esac
  if [[ "${kernel_path}" == *.jar ]]; then
    printf '%s\n' "java"
    return
  fi
  case "${kernel_path}" in
    *.cmd|*.bat|*.ps1|*.mjs|*.cjs|*.js)
      printf '%s\n' "node"
      return
      ;;
    *.exe)
      printf '%s\n' "native"
      return
      ;;
  esac
  if head -c 2 "${kernel_path}" 2>/dev/null | grep -q '^#!'; then
    printf '%s\n' "native"
    return
  fi
  printf '%s\n' "native"
}

process_kernel_output() {
  local stdout_file="${1:?stdout file required}"
  local stderr_file="${2:?stderr file required}"
  if [[ -s "${stderr_file}" ]]; then
    cat "${stderr_file}" >&2
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "${stdout_file}" <<'PY'
import json
import sys
from pathlib import Path

path = Path(sys.argv[1])
try:
    data = path.read_text(encoding='utf-8')
except FileNotFoundError:
    sys.exit(1)
if not data:
    sys.exit(1)

decoder = json.JSONDecoder()
best = None
idx = 0
while True:
    try:
        start = data.index('{', idx)
    except ValueError:
        break
    try:
        obj, length = decoder.raw_decode(data[start:])
    except json.JSONDecodeError:
        idx = start + 1
        continue
    end = start + length
    if best is None or end > best[2]:
        best = (obj, start, end)
    idx = start + 1

if best is None:
    sys.stderr.write(data)
    if not data.endswith('\n'):
        sys.stderr.write('\n')
    sys.exit(1)

obj, start, end = best
logs = data[:start] + data[end:]
if logs:
    sys.stderr.write(logs)
    if not logs.endswith('\n'):
        sys.stderr.write('\n')

json.dump(obj, sys.stdout, indent=2, ensure_ascii=False)
sys.stdout.write('\n')
sys.exit(0)
PY
    return $?
  fi
  return 1
}

build_inline_json() {
  if [[ $# -eq 0 ]]; then
    return 1
  fi
  local json
  if command -v python3 >/dev/null 2>&1; then
    if json=$(python3 - "$@" <<'PY'
import json
import sys

pairs = sys.argv[1:]
result = {}
for item in pairs:
    if '=' not in item:
        raise SystemExit(1)
    key, value = item.split('=', 1)
    value = value.strip()
    lowered = value.lower()
    if lowered in ('true', 'false'):
        result[key] = (lowered == 'true')
        continue
    if lowered == 'null':
        result[key] = None
        continue
    try:
        number = float(value)
    except ValueError:
        number = None
    else:
        if number.is_integer():
            number = int(number)
        result[key] = number
        continue
    prefixes = ('json:', 'JSON:', '@json:', '@JSON:')
    if value.startswith(prefixes):
        payload = value.split(':', 1)[1]
        result[key] = json.loads(payload)
        continue
    result[key] = value
print(json.dumps(result, separators=(',', ':')))
PY
); then
      printf '%s' "${json}"
      return 0
    fi
  fi
  local first=1
  local out="{"
  local pair key value escaped
  for pair in "$@"; do
    if [[ "${pair}" != *=* ]]; then
      return 1
    fi
    key=${pair%%=*}
    value=${pair#*=}
    escaped=${value//\\/\\\\}
    escaped=${escaped//\"/\\\"}
    if [[ ${first} -eq 0 ]]; then
      out+=','
    fi
    first=0
    out+="\"${key}\":\"${escaped}\""
  done
  out+='}'
  printf '%s' "${out}"
  return 0
}

flag_requires_value() {
  case "$1" in
    --compose|-c|--state|-s|--modules|-m|--bind|-b|--project|--config|--output|--cache-dir|--sources|--timeout|--log-level|--input|--kernel)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

cmd_version() {
  ensure_environment
  local version_file="${ROOT_DIR}/VERSION"
  local local_version="dev"
  if [[ -f "${version_file}" ]]; then
    local_version="$(<"${version_file}")"
  fi

  local remote_version=""
  local fetch_failed="false"
  local fetched="false"
  if needs_update 1; then
    if remote_version=$(update_version_cache); then
      fetched="true"
    else
      fetch_failed="true"
      remote_version=""
    fi
  fi

  if [[ -z "${remote_version}" ]]; then
    remote_version=$(get_cached_remote_version)
  fi

  echo "CLI version: ${local_version}"
  if [[ -n "${remote_version}" ]]; then
    local status="up to date"
    if [[ "${remote_version}" != "${local_version}" ]]; then
      status="update available"
    fi
    local fetched_at
    fetched_at=$(get_cached_version_timestamp)
    if [[ -n "${fetched_at}" ]]; then
      echo "Upstream release: ${remote_version} (${status}, checked ${fetched_at})"
    else
      echo "Upstream release: ${remote_version} (${status})"
    fi
    if [[ "${fetched}" == "true" ]]; then
      log_info "Fetched latest release information (${remote_version})."
    fi
  else
    if [[ "${fetch_failed}" == "true" ]]; then
      log_warn "Could not refresh latest release information."
    else
      log_warn "No upstream release information cached yet."
    fi
  fi
}

cmd_kernel_ls() {
  ensure_environment
  local count
  count=$(jq '.installedKernels | length' "${LCOD_CONFIG}")
  if [[ "${count}" -eq 0 ]]; then
    log_info "No kernels installed yet."
    log_info "Use 'lcod kernel install <id>' once the command is available."
    return
  fi

  local default_id
  default_id=$(config_get_default_kernel)
  printf 'ID\tVersion\tPath\tDefault\n'
  jq -r --arg default "${default_id}" '
    .installedKernels[]
    | "\(.id // "-")\t\(.version // "n/a")\t\(.path // "-")\t" + (if .id == $default and $default != "" then "yes" else "no" end)
  ' "${LCOD_CONFIG}"
}

cmd_kernel_default() {
  local kernel_id="${1:-}"
  if [[ -z "${kernel_id}" ]]; then
    log_error "Usage: lcod kernel default <kernel-id>"
    exit 1
  fi
  ensure_environment
  if ! config_kernel_exists "${kernel_id}"; then
    log_warn "Kernel '${kernel_id}' not found in manifest; recording default anyway."
  fi
  config_set_default_kernel "${kernel_id}"
  log_info "Default kernel set to '${kernel_id}'."
}

cmd_kernel_install() {
  local kernel_id="${1:-}"
  shift || true

  if [[ -z "${kernel_id}" ]]; then
    log_error "Usage: lcod kernel install <kernel-id> [--path <binary> | --from-release] [--version <version>] [--platform <id>] [--repo <owner/repo>] [--force]"
    exit 1
  fi

  local source_path=""
  local version=""
  local force="false"
  local from_release="false"
  local release_platform=""
  local release_repo="${LCOD_RELEASE_REPO:-}"
  local cleanup_dir=""
  local asset_path=""
  local default_from_release="false"

  local mapped_repo
  if mapped_repo=$(resolve_kernel_repo "${kernel_id}" 2>/dev/null); then
    release_repo="${release_repo:-${mapped_repo}}"
    default_from_release="true"
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path)
        source_path="${2:-}"
        shift 2 || true
        ;;
      --from-release)
        from_release="true"
        shift
        ;;
      --version)
        version="${2:-}"
        shift 2 || true
        ;;
      --platform)
        release_platform="${2:-}"
        shift 2 || true
        ;;
      --repo)
        release_repo="${2:-}"
        shift 2 || true
        ;;
      --force)
        force="true"
        shift
        ;;
      -h|--help)
        log_info "Usage: lcod kernel install <kernel-id> [--path <binary> | --from-release] [--version <version>] [--platform <id>] [--repo <owner/repo>] [--force]"
        return 0
        ;;
      *)
        log_error "Unknown option for kernel install: $1"
        exit 1
        ;;
    esac
  done

  if [[ "${from_release}" != "true" && -z "${source_path}" && "${default_from_release}" == "true" ]]; then
    from_release="true"
  fi

  if [[ "${from_release}" == "true" ]]; then
    if [[ -z "${release_repo}" ]]; then
      log_error "No release repository configured for kernel '${kernel_id}'. Use --repo <owner/repo>."
      exit 1
    fi
    if [[ -z "${version}" ]]; then
      if ! version=$(fetch_latest_runtime_version "${release_repo}"); then
        exit 1
      fi
    fi

    local tag=""
    local asset_name=""
    local cache_dir="${LCOD_CACHE_DIR}/releases/${version}"
    mkdir -p "${cache_dir}"
    local asset_url=""

    case "${kernel_id}" in
      rs|rust)
        if [[ -z "${release_platform}" || "${release_platform}" == "auto" ]]; then
          if ! release_platform=$(detect_platform); then
            log_error "Failed to auto-detect platform; use --platform explicitly."
            exit 1
          fi
        fi
        local extension
        if ! extension=$(release_asset_extension "${release_platform}"); then
          exit 1
        fi
        tag="lcod-run-v${version}"
        asset_name="lcod-run-${release_platform}.${extension}"
        local manifest_url
        if manifest_url=$(manifest_resolve_asset_url "${version}" "rs" "${asset_name}"); then
          asset_url="${manifest_url}"
        else
          asset_url="https://github.com/${release_repo}/releases/download/${tag}/${asset_name}"
        fi
        ;;
      node|js)
        if [[ -n "${release_platform}" && "${release_platform}" != "auto" ]]; then
          log_warn "Ignoring --platform for kernel '${kernel_id}' (runtime is platform agnostic)."
        fi
        tag="v${version}"
        asset_name="lcod-kernel-js-runtime-${version}.tar.gz"
        local manifest_url
        if manifest_url=$(manifest_resolve_asset_url "${version}" "js" "${asset_name}"); then
          asset_url="${manifest_url}"
        else
          asset_url="https://github.com/${release_repo}/releases/download/${tag}/${asset_name}"
        fi
        release_platform=""
        ;;
      java|jvm)
        if [[ -n "${release_platform}" && "${release_platform}" != "auto" ]]; then
          log_warn "Ignoring --platform for kernel '${kernel_id}' (runtime is platform agnostic)."
        fi
        tag="v${version}"
        asset_name="lcod-run-${version}.jar"
        local manifest_url
        if manifest_url=$(manifest_resolve_asset_url "${version}" "java" "${asset_name}"); then
          asset_url="${manifest_url}"
        else
          asset_url="https://github.com/${release_repo}/releases/download/${tag}/${asset_name}"
        fi
        release_platform=""
        ;;
      *)
        log_error "Kernel '${kernel_id}' is not supported for release installation."
        exit 1
        ;;
    esac

    asset_path="${cache_dir}/${asset_name}"

    if [[ "${force}" == "true" || ! -f "${asset_path}" ]]; then
      log_info "Downloading ${asset_url}"
      if ! download_file "${asset_url}" "${asset_path}"; then
        log_error "Failed to download ${asset_url}"
        exit 1
      fi
    else
      log_info "Using cached release asset ${asset_path}"
    fi

    local cleanup_dir=""
    local candidate=""
    local kernel_cache_dir=""

    case "${kernel_id}" in
      rs|rust)
        cleanup_dir=$(mktemp -d)
        if ! extract_archive "${asset_path}" "${cleanup_dir}"; then
          rm -rf "${cleanup_dir}"
          exit 1
        fi
        candidate=$(find "${cleanup_dir}" -maxdepth 2 -type f \( -name 'lcod-run' -o -name 'lcod-run.exe' \) | head -n1 || true)
        if [[ -z "${candidate}" ]]; then
          rm -rf "${cleanup_dir}"
          log_error "Unable to locate lcod-run binary inside archive ${asset_name}"
          exit 1
        fi
        ;;
      node|js)
        cleanup_dir=$(mktemp -d)
        if ! extract_archive "${asset_path}" "${cleanup_dir}"; then
          rm -rf "${cleanup_dir}"
          exit 1
        fi
        local runtime_manifest
        runtime_manifest=$(find "${cleanup_dir}" -maxdepth 4 -type f -name 'manifest.json' | head -n1 || true)
        if [[ -z "${runtime_manifest}" ]]; then
          rm -rf "${cleanup_dir}"
          log_error "Downloaded runtime archive does not contain a manifest (lcod-kernel-js-runtime)."
          exit 1
        fi
        local runtime_root
        runtime_root=$(dirname "${runtime_manifest}")
        kernel_cache_dir="${LCOD_CACHE_DIR}/kernels/${kernel_id}/${version}"
        rm -rf "${kernel_cache_dir}"
        mkdir -p "${kernel_cache_dir}"
        mv "${runtime_root}" "${kernel_cache_dir}/runtime"
        require_command npm "Install Node.js (npm) to set up the Node kernel."
        local source_archive_url="https://github.com/${release_repo}/archive/refs/tags/${tag}.tar.gz"
        local source_archive="${kernel_cache_dir}/source-${version}.tar.gz"
        if ! download_file "${source_archive_url}" "${source_archive}"; then
          rm -rf "${cleanup_dir}" "${kernel_cache_dir}"
          log_error "Failed to download Node kernel sources from ${source_archive_url}"
          exit 1
        fi
        local source_root_dir="${kernel_cache_dir}/source"
        rm -rf "${source_root_dir}"
        mkdir -p "${source_root_dir}"
        if ! tar -xzf "${source_archive}" -C "${source_root_dir}"; then
          rm -rf "${cleanup_dir}" "${kernel_cache_dir}"
          log_error "Unable to extract Node kernel sources archive"
          exit 1
        fi
        rm -f "${source_archive}"
        local node_source_root
        node_source_root=$(find "${source_root_dir}" -mindepth 1 -maxdepth 1 -type d | head -n1 || true)
        if [[ -z "${node_source_root}" ]]; then
          rm -rf "${cleanup_dir}" "${kernel_cache_dir}"
          log_error "Unable to locate Node kernel source directory after extraction"
          exit 1
        fi
        log_info "Installing Node kernel dependencies via npm"
        (
          cd "${node_source_root}"
          if ! npm ci >/dev/null 2>&1; then
            log_warn "npm ci failed; falling back to npm install"
            npm install >/dev/null 2>&1
          fi
        ) || {
          rm -rf "${cleanup_dir}" "${kernel_cache_dir}"
          log_error "Failed to install Node kernel dependencies"
          exit 1
        }
        local node_runner_path="${node_source_root}/bin/run-compose.mjs"
        if [[ ! -f "${node_runner_path}" ]]; then
          rm -rf "${cleanup_dir}" "${kernel_cache_dir}"
          log_error "Node kernel runner script missing at ${node_runner_path}"
          exit 1
        fi
        local wrapper="${cleanup_dir}/lcod-run"
        cat > "${wrapper}" <<EOF_NODE
#!/usr/bin/env bash
set -euo pipefail
export LCOD_HOME="${kernel_cache_dir}/runtime"
export SPEC_REPO_PATH="${kernel_cache_dir}/runtime"
export LCOD_RESOLVER_PATH="\${LCOD_RESOLVER_PATH:-${kernel_cache_dir}/runtime/resolver}"
exec node "${node_source_root}/bin/run-compose.mjs" --core --resolver "\$@"
EOF_NODE
        chmod +x "${wrapper}"
        candidate="${wrapper}"
        ;;
      java|jvm)
        cleanup_dir=$(mktemp -d)
        kernel_cache_dir="${LCOD_CACHE_DIR}/kernels/${kernel_id}/${version}"
        rm -rf "${kernel_cache_dir}"
        mkdir -p "${kernel_cache_dir}"
        local java_jar="${kernel_cache_dir}/lcod-run-${version}.jar"
        cp "${asset_path}" "${java_jar}"
        local wrapper_java="${cleanup_dir}/lcod-run"
        cat > "${wrapper_java}" <<EOF_JAVA
#!/usr/bin/env bash
set -euo pipefail
exec java -jar "${java_jar}" "\$@"
EOF_JAVA
        chmod +x "${wrapper_java}"
        candidate="${wrapper_java}"
        ;;
      *)
        log_error "Unsupported kernel installation strategy for '${kernel_id}'."
        exit 1
        ;;
    esac

    source_path="${candidate:-}"
  fi

  if [[ -z "${source_path}" ]]; then
    log_error "Provide --path <binary> or --from-release"
    exit 1
  fi

  if [[ ! -f "${source_path}" ]]; then
    log_error "Source binary not found at ${source_path}"
    [[ -n "${cleanup_dir}" ]] && rm -rf "${cleanup_dir}"
    exit 1
  fi

  ensure_environment

  local destination="${LCOD_BIN_DIR}/${kernel_id}"
  if [[ -f "${destination}" && "${force}" != "true" ]]; then
    log_error "Kernel '${kernel_id}' already installed at ${destination} (use --force to overwrite)"
    exit 1
  fi

  mkdir -p "${LCOD_BIN_DIR}"
  cp "${source_path}" "${destination}"
  chmod +x "${destination}"
  clear_quarantine_if_needed "${destination}"

  config_add_or_update_kernel "${kernel_id}" "${version}" "${destination}"

  log_info "Kernel '${kernel_id}' installed at ${destination}"
  if [[ -n "${version}" ]]; then
    log_info "Recorded version ${version}"
  fi
  if [[ "${from_release}" == "true" ]]; then
    log_info "Source: ${asset_path}"
  fi

  if [[ -n "${cleanup_dir}" ]]; then
    rm -rf "${cleanup_dir}"
  fi

  update_kernel_update_cache "${kernel_id}" "${version}" "$(current_epoch)"
}

cmd_run() {
  ensure_environment

  local kernel_id=""
  local args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --kernel)
        kernel_id="${2:-}"
        shift 2 || true
        ;;
      -h|--help)
        cat <<'EOF'
Usage: lcod run [--kernel <id>] [--] <args...>

Executes the configured kernel runtime (defaulting to the one marked as default) and forwards the provided arguments.
EOF
        return 0
        ;;
      --)
        shift
        args+=("$@")
        break
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  if [[ -z "${kernel_id}" ]]; then
    kernel_id=$(config_get_default_kernel)
  fi

  if [[ -z "${kernel_id}" ]]; then
    log_error "No default kernel configured. Install one with 'lcod kernel install <id>' or pass --kernel explicitly."
    exit 1
  fi

  if ! config_kernel_exists "${kernel_id}"; then
    log_error "Kernel '${kernel_id}' is not registered. Install it first."
    exit 1
  fi

  auto_update_kernel_if_needed "${kernel_id}"

  local kernel_path
  kernel_path=$(config_get_kernel_path "${kernel_id}")
  if [[ -z "${kernel_path}" || ! -e "${kernel_path}" ]]; then
    log_error "Kernel binary for '${kernel_id}' not found at ${kernel_path}."
    exit 1
  fi

  local kernel_type
  kernel_type=$(detect_kernel_type "${kernel_path}" "${kernel_id}")

  local has_compose_flag=0
  for arg in "${args[@]}"; do
    if [[ "${arg}" == "--compose" || "${arg}" == "-c" ]]; then
      has_compose_flag=1
      break
    fi
  done

  local compose_value=""
  local kv_pairs=()
  local forwarded=()
  local after_delim=0
  local expect_compose_value=0
  local expect_flag_value=0

  for arg in "${args[@]}"; do
    if [[ ${after_delim} -eq 1 ]]; then
      forwarded+=("${arg}")
      continue
    fi
    if [[ ${expect_compose_value} -eq 1 ]]; then
      forwarded+=("${arg}")
      expect_compose_value=0
      continue
    fi
    if [[ ${expect_flag_value} -eq 1 ]]; then
      forwarded+=("${arg}")
      expect_flag_value=0
      continue
    fi
    case "${arg}" in
      --)
        after_delim=1
        forwarded+=("${arg}")
        ;;
      --compose|-c)
        forwarded+=("${arg}")
        expect_compose_value=1
        ;;
      -*)
        forwarded+=("${arg}")
        if flag_requires_value "${arg}"; then
          expect_flag_value=1
        fi
        ;;
      *)
        if [[ ${has_compose_flag} -eq 0 && -z "${compose_value}" ]]; then
          compose_value="${arg}"
        elif [[ ${has_compose_flag} -eq 0 && "${arg}" == *=* ]]; then
          kv_pairs+=("${arg}")
        else
          forwarded+=("${arg}")
        fi
        ;;
    esac
  done

  local inline_json=""
  if [[ ${#kv_pairs[@]} -gt 0 ]]; then
    if ! inline_json=$(build_inline_json "${kv_pairs[@]}"); then
      log_warn "Unable to parse inline arguments into JSON; forwarding raw values."
      forwarded+=("${kv_pairs[@]}")
      inline_json=""
    fi
  fi

  local transformed=()
  if [[ -n "${compose_value}" ]]; then
    transformed+=("--compose" "${compose_value}")
  fi

  if [[ -n "${inline_json}" ]]; then
    case "${kernel_type}" in
      node)
        transformed+=("--state" "${inline_json}")
        ;;
      *)
        transformed+=("--input" "${inline_json}")
        ;;
    esac
  fi

  args=("${transformed[@]}" "${forwarded[@]}")

  local cmd
  local forward=()

  case "${kernel_path}" in
    *.jar)
      cmd="java"
      forward=(-jar "${kernel_path}")
      ;;
    *.mjs|*.cjs|*.js)
      cmd="node"
      forward=("${kernel_path}")
      ;;
    *.ps1)
      if command -v pwsh >/dev/null 2>&1; then
        cmd="pwsh"
      else
        cmd="powershell"
      fi
      forward=(-File "${kernel_path}")
      ;;
    *.bat|*.cmd)
      cmd="${kernel_path}"
      ;;
    *)
      cmd="${kernel_path}"
      ;;
  esac

  if [[ ${#args[@]} -gt 0 ]]; then
    forward+=("${args[@]}")
  fi

  local tmp_stdout tmp_stderr status
  tmp_stdout=$(mktemp)
  tmp_stderr=$(mktemp)
  "${cmd}" "${forward[@]}" >"${tmp_stdout}" 2>"${tmp_stderr}"
  status=$?
  if ! process_kernel_output "${tmp_stdout}" "${tmp_stderr}"; then
    cat "${tmp_stdout}"
  fi
  rm -f "${tmp_stdout}" "${tmp_stderr}"
  return "${status}"
}

cmd_kernel_remove() {
  local kernel_id="${1:-}"
  if [[ -z "${kernel_id}" ]]; then
    log_error "Usage: lcod kernel remove <kernel-id>"
    exit 1
  fi

  ensure_environment

  if ! config_kernel_exists "${kernel_id}"; then
    log_warn "Kernel '${kernel_id}' not registered; nothing to remove."
    return 0
  fi

  local existing_path
  existing_path=$(config_get_kernel_path "${kernel_id}")

  if [[ -n "${existing_path}" && -f "${existing_path}" ]]; then
    if [[ "${existing_path}" == "${LCOD_BIN_DIR}/"* ]]; then
      rm -f "${existing_path}"
      log_info "Removed binary ${existing_path}"
    else
      log_warn "Skipping deletion of ${existing_path} (outside managed bin directory)."
    fi
  fi

  config_remove_kernel "${kernel_id}"
  log_info "Kernel '${kernel_id}' removed from manifest."
}

cmd_cache_clean() {
  ensure_environment
  if [[ -d "${LCOD_CACHE_DIR}" ]]; then
    rm -rf "${LCOD_CACHE_DIR:?}/"*
    log_info "Cache cleared."
  else
    log_info "Cache directory not present."
  fi
}

cmd_self_update() {
  ensure_environment
  log_info "Self-update placeholder. Will download latest release in future iteration."
  touch_update_stamp
}

main() {
  ensure_environment
  maybe_auto_update_cli

  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    help|-h|--help)
      print_help
      ;;
    version)
      cmd_version "$@"
      ;;
    kernel)
      local sub="${1:-}"
      shift || true
      case "${sub}" in
        ls)
          cmd_kernel_ls "$@"
          ;;
        install)
          cmd_kernel_install "$@"
          ;;
        remove|rm|delete)
          cmd_kernel_remove "$@"
          ;;
        default)
          cmd_kernel_default "$@"
          ;;
        *)
          log_error "Unknown kernel subcommand '${sub}'"
          exit 1
          ;;
      esac
      ;;
    run)
      cmd_run "$@"
      ;;
    cache)
      local sub="${1:-}"
      shift || true
      case "${sub}" in
        clean)
          cmd_cache_clean "$@"
          ;;
        *)
          log_error "Unknown cache subcommand '${sub}'"
          exit 1
          ;;
      esac
      ;;
    self-update)
      cmd_self_update "$@"
      ;;
    *)
      log_error "Unknown command '${cmd}'"
      print_help
      exit 1
      ;;
  esac
}

main "$@"
