#!/usr/bin/env bash
# Auto-generated by scripts/build-bundle.sh on 2025-10-30T11:25:42Z
set -eo pipefail

# ---- Inlined common library ----
#!/usr/bin/env bash
# shellcheck shell=bash

set -eo pipefail

LCOD_STATE_DIR="${LCOD_STATE_DIR:-${HOME}/.lcod}"
LCOD_BIN_DIR="${LCOD_BIN_DIR:-${LCOD_STATE_DIR}/bin}"
LCOD_CACHE_DIR="${LCOD_CACHE_DIR:-${LCOD_STATE_DIR}/cache}"
LCOD_CONFIG="${LCOD_CONFIG:-${LCOD_STATE_DIR}/config.json}"
LCOD_UPDATE_STAMP="${LCOD_STATE_DIR}/last-update"
LCOD_VERSION_CACHE="${LCOD_STATE_DIR}/latest-version.json"
LCOD_CLI_UPDATE_CACHE="${LCOD_STATE_DIR}/cli-update.json"
LCOD_KERNEL_UPDATE_CACHE="${LCOD_STATE_DIR}/kernel-update.json"
LCOD_AUTO_UPDATE_INTERVAL_DEFAULT=86400
LCOD_AUTO_UPDATE_INTERVAL="${LCOD_AUTO_UPDATE_INTERVAL:-${LCOD_AUTO_UPDATE_INTERVAL_DEFAULT}}"

log_info() {
  printf '[INFO] %s\n' "$*"
}

log_warn() {
  printf '[WARN] %s\n' "$*" >&2
}

log_error() {
  printf '[ERROR] %s\n' "$*" >&2
}

require_command() {
  local cmd="$1"
  local help_msg="${2:-Install the missing command and retry.}"
  if ! command -v "${cmd}" >/dev/null 2>&1; then
    log_error "'${cmd}' is required. ${help_msg}"
    exit 1
  fi
}

ensure_dirs() {
  mkdir -p "${LCOD_STATE_DIR}" "${LCOD_BIN_DIR}" "${LCOD_CACHE_DIR}"
}

ensure_config() {
  if [[ ! -f "${LCOD_CONFIG}" ]]; then
    cat <<'JSON' > "${LCOD_CONFIG}"
{
  "defaultKernel": null,
  "installedKernels": [],
  "lastUpdateCheck": null
}
JSON
  fi
}

ensure_environment() {
  require_command jq "Install jq to parse LCOD configuration files."
  ensure_dirs
  ensure_config
}

fetch_latest_version() {
  local release_repo="${1:-lcod-dev/lcod-release}"
  local version_url="https://raw.githubusercontent.com/${release_repo}/main/VERSION"
  curl -fsSL "${version_url}" 2>/dev/null
}

fetch_latest_runtime_version() {
  require_command curl "Install curl to query GitHub releases."
  local repo="${1:?repo required}"
  local api_url="https://api.github.com/repos/${repo}/releases/latest"
  local tag
  tag=$(curl -fsSL -H "Accept: application/vnd.github+json" "${api_url}" | jq -r '.tag_name // empty')
  if [[ -z "${tag}" ]]; then
    log_error "Unable to determine latest release for ${repo}"
    return 1
  fi
  tag="${tag#lcod-run-v}"
  tag="${tag#v}"
  printf '%s' "${tag}"
}

detect_platform() {
  local os=""
  local machine_arch=""
  os=$(uname -s | tr '[:upper:]' '[:lower:]')
  machine_arch=$(uname -m)

  case "${os}" in
    linux)
      case "${machine_arch:-}" in
        x86_64|amd64) echo "linux-x86_64" ;;
        aarch64|arm64) echo "linux-arm64" ;;
        *) log_error "Unsupported Linux architecture: ${machine_arch:-unknown}"; return 1 ;;
      esac
      ;;
    darwin)
      case "${machine_arch:-}" in
        x86_64|amd64) echo "macos-x86_64" ;;
        arm64) echo "macos-arm64" ;;
        *) log_error "Unsupported macOS architecture: ${machine_arch:-unknown}"; return 1 ;;
      esac
      ;;
    msys*|mingw*|cygwin*)
      case "${machine_arch:-}" in
        x86_64|amd64) echo "windows-x86_64" ;;
        arm64) echo "windows-arm64" ;;
        *) log_error "Unsupported Windows architecture: ${machine_arch:-unknown}"; return 1 ;;
      esac
      ;;
    *)
      log_error "Unsupported operating system: ${os}"
      return 1
      ;;
  esac
}

make_release_asset_url() {
  local repo="${1:?repo required}"
  local version="${2:?version required}"
  local platform="${3:?platform required}"
  local extension
  extension=$(release_asset_extension "${platform}") || return 1
  local base="https://github.com/${repo}/releases/download"
  printf "%s/lcod-run-v%s/lcod-run-%s.%s" "${base}" "${version}" "${platform}" "${extension}"
}

release_asset_extension() {
  local platform="${1:?platform required}"
  case "${platform}" in
    windows-*) echo "zip" ;;
    *) echo "tar.gz" ;;
  esac
}

download_file() {
  require_command curl "Install curl to download LCOD assets."
  local url="${1:?url required}"
  local output="${2:?output path required}"
  curl -fL --progress-bar "${url}" -o "${output}"
}

extract_archive() {
  local archive="${1:?archive required}"
  local destination="${2:?destination required}"
  local extension
  extension="${archive##*.}"
  mkdir -p "${destination}"
  case "${extension}" in
    zip)
      require_command unzip "Install unzip to extract Windows archives."
      unzip -o "${archive}" -d "${destination}" >/dev/null
      ;;
    gz)
      require_command tar "Install tar to extract LCOD archives."
      tar -xzf "${archive}" -C "${destination}"
      ;;
    *)
      log_error "Unsupported archive format: ${archive}"
      return 1
      ;;
  esac
}

update_version_cache() {
  ensure_environment
  local release_repo="${1:-lcod-dev/lcod-release}"
  local version
  if ! version=$(fetch_latest_version "${release_repo}"); then
    return 1
  fi
  local iso
  iso=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  cat <<JSON > "${LCOD_VERSION_CACHE}"
{
  "version": "${version}",
  "source": "${release_repo}",
  "fetchedAt": "${iso}"
}
JSON
  touch_update_stamp
  printf '%s' "${version}"
}

get_cached_remote_version() {
  if [[ -f "${LCOD_VERSION_CACHE}" ]]; then
    jq -r '.version // empty' "${LCOD_VERSION_CACHE}" 2>/dev/null || true
  fi
}

get_cached_version_timestamp() {
  if [[ -f "${LCOD_VERSION_CACHE}" ]]; then
    jq -r '.fetchedAt // empty' "${LCOD_VERSION_CACHE}" 2>/dev/null || true
  fi
}

needs_update() {
  local period_days="${1:-1}"
  if [[ ! -f "${LCOD_UPDATE_STAMP}" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 <<PY
import os, time, sys
stamp = os.path.getmtime("${LCOD_UPDATE_STAMP}")
threshold = time.time() - (${period_days} * 86400)
sys.exit(0 if stamp < threshold else 1)
PY
    return $?
  fi

  local now stamp threshold
  now=$(date +%s)
  stamp=$(date -r "${LCOD_UPDATE_STAMP}" +%s 2>/dev/null || echo 0)
  threshold=$(( now - period_days * 86400 ))
  [[ "${stamp}" -lt "${threshold}" ]]
}

touch_update_stamp() {
  ensure_environment
  local iso
  iso=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  printf '%s\n' "${iso}" > "${LCOD_UPDATE_STAMP}"
  local tmp
  tmp=$(mktemp)
  jq --arg ts "${iso}" '.lastUpdateCheck = $ts' "${LCOD_CONFIG}" > "${tmp}"
  mv "${tmp}" "${LCOD_CONFIG}"
}

config_get_default_kernel() {
  jq -r '.defaultKernel // ""' "${LCOD_CONFIG}"
}

config_set_default_kernel() {
  ensure_environment
  local kernel_id="${1:-}"
  local tmp
  tmp=$(mktemp)
  if [[ -z "${kernel_id}" ]]; then
    jq '.defaultKernel = null' "${LCOD_CONFIG}" > "${tmp}"
  else
    jq --arg id "${kernel_id}" '.defaultKernel = $id' "${LCOD_CONFIG}" > "${tmp}"
  fi
  mv "${tmp}" "${LCOD_CONFIG}"
}

config_kernel_exists() {
  local kernel_id="${1:-}"
  jq -e --arg id "${kernel_id}" '.installedKernels[]? | select(.id == $id)' "${LCOD_CONFIG}" >/dev/null 2>&1
}

clear_quarantine_if_needed() {
  local target="${1:-}"
  if [[ -z "${target}" || ! -e "${target}" ]]; then
    return
  fi

  if [[ "$(uname -s)" == "Darwin" ]]; then
    if command -v xattr >/dev/null 2>&1; then
      if ! xattr -cr "${target}" 2>/dev/null; then
        log_warn "Failed to clear quarantine attributes on ${target}"
      fi
    fi
  fi
}

config_add_or_update_kernel() {
  ensure_environment
  local kernel_id="${1:?kernel id required}"
  local kernel_version="${2:-}"
  local kernel_path="${3:?kernel path required}"

  local tmp
  tmp=$(mktemp)
  jq \
    --arg id "${kernel_id}" \
    --arg version "${kernel_version}" \
    --arg path "${kernel_path}" \
    '
      .installedKernels =
        ([.installedKernels[]? | select(.id != $id)] + [{
          id: $id,
          version: (if $version == "" then null else $version end),
          path: $path
        }])
      | (if (.defaultKernel == null or .defaultKernel == "") then (.defaultKernel = $id) else . end)
    ' "${LCOD_CONFIG}" > "${tmp}"
  mv "${tmp}" "${LCOD_CONFIG}"
}

config_remove_kernel() {
  ensure_environment
  local kernel_id="${1:?kernel id required}"
  local tmp
  tmp=$(mktemp)
  jq --arg id "${kernel_id}" '
    .installedKernels = [.installedKernels[]? | select(.id != $id)] |
    (if .defaultKernel == $id then
      (if (.installedKernels | length) > 0 then
         (.defaultKernel = (.installedKernels[0].id))
       else
         (.defaultKernel = null)
       end)
     else . end)
  ' "${LCOD_CONFIG}" > "${tmp}"
  mv "${tmp}" "${LCOD_CONFIG}"
}

config_list_kernels() {
  jq '.' "${LCOD_CONFIG}"
}

config_get_kernel_path() {
  local kernel_id="${1:?kernel id required}"
  jq -r --arg id "${kernel_id}" '
    (.installedKernels[]? | select(.id == $id) | .path) // empty
  ' "${LCOD_CONFIG}"
}

current_epoch() {
  date -u +%s
}

get_cli_cached_version() {
  if [[ -f "${LCOD_CLI_UPDATE_CACHE}" ]]; then
    jq -r '.version // ""' "${LCOD_CLI_UPDATE_CACHE}" 2>/dev/null || true
  fi
}

get_cli_last_check() {
  if [[ -f "${LCOD_CLI_UPDATE_CACHE}" ]]; then
    jq -r '.lastCheck // 0' "${LCOD_CLI_UPDATE_CACHE}" 2>/dev/null || printf '0'
  else
    printf '0'
  fi
}

write_cli_update_cache() {
  local version="$1"
  local timestamp="$2"
  mkdir -p "${LCOD_STATE_DIR}"
  jq -n --arg version "${version}" --argjson lastCheck "${timestamp}" '{version:$version,lastCheck:$lastCheck}' > "${LCOD_CLI_UPDATE_CACHE}"
}

get_kernel_update_info() {
  local kernel_id="${1:?kernel id required}"
  if [[ -f "${LCOD_KERNEL_UPDATE_CACHE}" ]]; then
    jq --arg id "${kernel_id}" '.kernels[$id] // {}' "${LCOD_KERNEL_UPDATE_CACHE}" 2>/dev/null || true
  fi
}

get_kernel_last_check() {
  local kernel_id="${1:?kernel id required}"
  if [[ -f "${LCOD_KERNEL_UPDATE_CACHE}" ]]; then
    jq -r --arg id "${kernel_id}" '.kernels[$id].lastCheck // 0' "${LCOD_KERNEL_UPDATE_CACHE}" 2>/dev/null || printf '0'
  else
    printf '0'
  fi
}

update_kernel_update_cache() {
  local kernel_id="${1:?kernel id required}"
  local version="${2:-}"
  local timestamp="${3:-0}"
  mkdir -p "${LCOD_STATE_DIR}"
  if [[ ! -f "${LCOD_KERNEL_UPDATE_CACHE}" ]]; then
    jq -n '{kernels:{}}' > "${LCOD_KERNEL_UPDATE_CACHE}"
  fi
  jq --arg id "${kernel_id}" --arg version "${version}" --argjson lastCheck "${timestamp}" '
    .kernels = (.kernels // {}) |
    .kernels[$id] = {version:$version,lastCheck:$lastCheck}
  ' "${LCOD_KERNEL_UPDATE_CACHE}" > "${LCOD_KERNEL_UPDATE_CACHE}.tmp" && mv "${LCOD_KERNEL_UPDATE_CACHE}.tmp" "${LCOD_KERNEL_UPDATE_CACHE}"
}

auto_update_interval() {
  local interval="${LCOD_AUTO_UPDATE_INTERVAL}"
  if [[ -z "${interval}" || ! "${interval}" =~ ^[0-9]+$ ]]; then
    echo "${LCOD_AUTO_UPDATE_INTERVAL_DEFAULT}"
  else
    echo "${interval}"
  fi
}

# ---- CLI bootstrap ----
SCRIPT_PATH="${BASH_SOURCE[0]}"
if [[ -z "${SCRIPT_PATH}" ]]; then
  SCRIPT_PATH="$0"
fi
if [[ "${SCRIPT_PATH}" != /* ]]; then
  SCRIPT_PATH="$(pwd)/${SCRIPT_PATH}"
fi
while [[ -h "${SCRIPT_PATH}" ]]; do
  LINK_DIR="$(cd -P "$(dirname "${SCRIPT_PATH}")" && pwd)"
  SCRIPT_PATH="$(readlink "${SCRIPT_PATH}")"
  if [[ "${SCRIPT_PATH}" != /* ]]; then
    SCRIPT_PATH="${LINK_DIR}/${SCRIPT_PATH}"
  fi
done
SCRIPT_DIR="$(cd -P "$(dirname "${SCRIPT_PATH}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/.." >/dev/null 2>&1 && pwd || printf '%s' "${SCRIPT_DIR}")"

# ---- CLI entrypoint ----
print_help() {
  cat <<'EOF'
Usage: lcod <command> [options]

Commands:
  version               Print the currently installed CLI version.
  kernel ls             List available kernels from the local manifest.
  kernel install <id>   Install or update a kernel (local path or release asset).
  kernel remove <id>    Remove a kernel from the manifest.
  kernel default <id>   Set the default kernel.
  run [options]         Execute the default kernel runtime with the given arguments.
  cache clean           Remove cached artefacts.
  self-update           Force immediate update check.
  help                  Show this message.

This is an early prototype. Most commands are placeholders until the backend scripts land.
EOF
}

resolve_kernel_repo() {
  local kernel_id="${1:?kernel id required}"
  case "${kernel_id}" in
    rs|rust)
      printf '%s' "${LCOD_RS_RELEASE_REPO:-lcod-team/lcod-kernel-rs}"
      ;;
    node|js)
      printf '%s' "${LCOD_NODE_RELEASE_REPO:-lcod-team/lcod-kernel-js}"
      ;;
    java|jvm)
      printf '%s' "${LCOD_JAVA_RELEASE_REPO:-lcod-team/lcod-kernel-java}"
      ;;
    *)
      return 1
      ;;
  esac
}

maybe_auto_update_cli() {
  if [[ "${LCOD_DISABLE_AUTO_UPDATE:-}" == "1" ]]; then
    return
  fi

  # Skip when running inside a repository checkout to avoid modifying tracked files
  if [[ -d "${ROOT_DIR}/.git" ]]; then
    return
  fi

  local interval
  interval=$(auto_update_interval)
  local now
  now=$(current_epoch)
  local last_check
  last_check=$(get_cli_last_check)
  if [[ -n "${interval}" && "${interval}" != "0" ]] && (( now - last_check < interval )); then
    return
  fi

  local cached_version
  cached_version=$(get_cli_cached_version)

  local script_path
  script_path=$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || printf '%s' "${BASH_SOURCE[0]}")

  if [[ ! -w "${script_path}" ]]; then
    write_cli_update_cache "${cached_version}" "${now}"
    return
  fi

  local remote_version
  if ! remote_version=$(fetch_latest_version "lcod-team/lcod-cli"); then
    write_cli_update_cache "${cached_version}" "${now}"
    return
  fi

  local tmp
  tmp=$(mktemp)
  local cli_url="${LCOD_CLI_SCRIPT_URL:-https://raw.githubusercontent.com/lcod-team/lcod-cli/main/dist/lcod}"
  if ! download_file "${cli_url}" "${tmp}"; then
    rm -f "${tmp}"
    write_cli_update_cache "${cached_version}" "${now}"
    return
  fi

  chmod +x "${tmp}"
  if mv "${tmp}" "${script_path}" 2>/dev/null; then
    cached_version="${remote_version}"
    log_info "CLI auto-updated to ${cached_version}."
    local lib_tmp
    lib_tmp=$(mktemp)
    local lib_url="${LCOD_CLI_LIB_URL:-https://raw.githubusercontent.com/lcod-team/lcod-cli/main/scripts/lib/common.sh}"
    if download_file "${lib_url}" "${lib_tmp}"; then
      mkdir -p "${SCRIPT_DIR}/lib"
      mv "${lib_tmp}" "${SCRIPT_DIR}/lib/common.sh"
    else
      rm -f "${lib_tmp}"
      log_warn "Failed to refresh CLI support library."
    fi
  else
    rm -f "${tmp}"
    log_warn "CLI auto-update failed (unable to write to ${script_path})."
  fi

  write_cli_update_cache "${cached_version}" "${now}"
}

auto_update_kernel_if_needed() {
  local kernel_id="${1:?kernel id required}"

  if [[ "${LCOD_DISABLE_AUTO_UPDATE:-}" == "1" ]]; then
    return
  fi

  local repo
  if ! repo=$(resolve_kernel_repo "${kernel_id}" 2>/dev/null); then
    return
  fi

  local interval
  interval=$(auto_update_interval)
  local now
  now=$(current_epoch)
  local last_check
  last_check=$(get_kernel_last_check "${kernel_id}")
  if [[ -n "${interval}" && "${interval}" != "0" ]] && (( now - last_check < interval )); then
    return
  fi

  local current_version
  current_version=$(jq -r --arg id "${kernel_id}" '.installedKernels[]? | select(.id == $id) | .version // ""' "${LCOD_CONFIG}")
  if [[ -z "${current_version}" ]]; then
    update_kernel_update_cache "${kernel_id}" "" "${now}"
    return
  fi

  local remote_version
  if ! remote_version=$(fetch_latest_runtime_version "${repo}"); then
    update_kernel_update_cache "${kernel_id}" "${current_version}" "${now}"
    return
  fi

  if [[ -n "${remote_version}" && "${remote_version}" != "${current_version}" ]]; then
    log_info "Auto-updating kernel '${kernel_id}' to ${remote_version}."
    if cmd_kernel_install "${kernel_id}" --from-release --version "${remote_version}" --force --repo "${repo}"; then
      current_version="${remote_version}"
    else
      log_warn "Auto-update failed for kernel '${kernel_id}'."
    fi
  fi

  update_kernel_update_cache "${kernel_id}" "${current_version}" "${now}"
}

cmd_version() {
  ensure_environment
  local version_file="${ROOT_DIR}/VERSION"
  local local_version="dev"
  if [[ -f "${version_file}" ]]; then
    local_version="$(<"${version_file}")"
  fi

  local remote_version=""
  local fetch_failed="false"
  local fetched="false"
  if needs_update 1; then
    if remote_version=$(update_version_cache); then
      fetched="true"
    else
      fetch_failed="true"
      remote_version=""
    fi
  fi

  if [[ -z "${remote_version}" ]]; then
    remote_version=$(get_cached_remote_version)
  fi

  echo "CLI version: ${local_version}"
  if [[ -n "${remote_version}" ]]; then
    local status="up to date"
    if [[ "${remote_version}" != "${local_version}" ]]; then
      status="update available"
    fi
    local fetched_at
    fetched_at=$(get_cached_version_timestamp)
    if [[ -n "${fetched_at}" ]]; then
      echo "Upstream release: ${remote_version} (${status}, checked ${fetched_at})"
    else
      echo "Upstream release: ${remote_version} (${status})"
    fi
    if [[ "${fetched}" == "true" ]]; then
      log_info "Fetched latest release information (${remote_version})."
    fi
  else
    if [[ "${fetch_failed}" == "true" ]]; then
      log_warn "Could not refresh latest release information."
    else
      log_warn "No upstream release information cached yet."
    fi
  fi
}

cmd_kernel_ls() {
  ensure_environment
  local count
  count=$(jq '.installedKernels | length' "${LCOD_CONFIG}")
  if [[ "${count}" -eq 0 ]]; then
    log_info "No kernels installed yet."
    log_info "Use 'lcod kernel install <id>' once the command is available."
    return
  fi

  local default_id
  default_id=$(config_get_default_kernel)
  printf 'ID\tVersion\tPath\tDefault\n'
  jq -r --arg default "${default_id}" '
    .installedKernels[]
    | "\(.id // "-")\t\(.version // "n/a")\t\(.path // "-")\t" + (if .id == $default and $default != "" then "yes" else "no" end)
  ' "${LCOD_CONFIG}"
}

cmd_kernel_default() {
  local kernel_id="${1:-}"
  if [[ -z "${kernel_id}" ]]; then
    log_error "Usage: lcod kernel default <kernel-id>"
    exit 1
  fi
  ensure_environment
  if ! config_kernel_exists "${kernel_id}"; then
    log_warn "Kernel '${kernel_id}' not found in manifest; recording default anyway."
  fi
  config_set_default_kernel "${kernel_id}"
  log_info "Default kernel set to '${kernel_id}'."
}

cmd_kernel_install() {
  local kernel_id="${1:-}"
  shift || true

  if [[ -z "${kernel_id}" ]]; then
    log_error "Usage: lcod kernel install <kernel-id> [--path <binary> | --from-release] [--version <version>] [--platform <id>] [--repo <owner/repo>] [--force]"
    exit 1
  fi

  local source_path=""
  local version=""
  local force="false"
  local from_release="false"
  local release_platform=""
  local release_repo="${LCOD_RELEASE_REPO:-}"
  local cleanup_dir=""
  local asset_path=""
  local default_from_release="false"

  local mapped_repo
  if mapped_repo=$(resolve_kernel_repo "${kernel_id}" 2>/dev/null); then
    release_repo="${release_repo:-${mapped_repo}}"
    default_from_release="true"
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path)
        source_path="${2:-}"
        shift 2 || true
        ;;
      --from-release)
        from_release="true"
        shift
        ;;
      --version)
        version="${2:-}"
        shift 2 || true
        ;;
      --platform)
        release_platform="${2:-}"
        shift 2 || true
        ;;
      --repo)
        release_repo="${2:-}"
        shift 2 || true
        ;;
      --force)
        force="true"
        shift
        ;;
      -h|--help)
        log_info "Usage: lcod kernel install <kernel-id> [--path <binary> | --from-release] [--version <version>] [--platform <id>] [--repo <owner/repo>] [--force]"
        return 0
        ;;
      *)
        log_error "Unknown option for kernel install: $1"
        exit 1
        ;;
    esac
  done

  if [[ "${from_release}" != "true" && -z "${source_path}" && "${default_from_release}" == "true" ]]; then
    from_release="true"
  fi

  if [[ "${from_release}" == "true" ]]; then
    if [[ -z "${release_repo}" ]]; then
      log_error "No release repository configured for kernel '${kernel_id}'. Use --repo <owner/repo>."
      exit 1
    fi
    if [[ -z "${version}" ]]; then
      if ! version=$(fetch_latest_runtime_version "${release_repo}"); then
        exit 1
      fi
    fi

    if [[ -z "${release_platform}" || "${release_platform}" == "auto" ]]; then
      if ! release_platform=$(detect_platform); then
        log_error "Failed to auto-detect platform; use --platform explicitly."
        exit 1
      fi
    fi

    local extension
    if ! extension=$(release_asset_extension "${release_platform}"); then
      exit 1
    fi

    local cache_dir="${LCOD_CACHE_DIR}/releases/${version}"
    mkdir -p "${cache_dir}"
    local asset_name="lcod-run-${version}-${release_platform}.${extension}"
    asset_path="${cache_dir}/${asset_name}"
    local asset_url
    if ! asset_url=$(make_release_asset_url "${release_repo}" "${version}" "${release_platform}"); then
      log_error "Unsupported platform for release asset"
      exit 1
    fi

    if [[ "${force}" == "true" || ! -f "${asset_path}" ]]; then
      log_info "Downloading ${asset_url}"
      if ! download_file "${asset_url}" "${asset_path}"; then
        log_error "Failed to download ${asset_url}"
        exit 1
      fi
    else
      log_info "Using cached release asset ${asset_path}"
    fi

    cleanup_dir=$(mktemp -d)
    if ! extract_archive "${asset_path}" "${cleanup_dir}"; then
      rm -rf "${cleanup_dir}"
      exit 1
    fi

    local candidate
    candidate=$(find "${cleanup_dir}" -maxdepth 2 -type f \( -name 'lcod-run' -o -name 'lcod-run.exe' \) | head -n1 || true)
    if [[ -z "${candidate}" ]]; then
      rm -rf "${cleanup_dir}"
      log_error "Unable to locate lcod-run binary inside archive ${asset_name}"
      exit 1
    fi
    source_path="${candidate}"
  fi

  if [[ -z "${source_path}" ]]; then
    log_error "Provide --path <binary> or --from-release"
    exit 1
  fi

  if [[ ! -f "${source_path}" ]]; then
    log_error "Source binary not found at ${source_path}"
    [[ -n "${cleanup_dir}" ]] && rm -rf "${cleanup_dir}"
    exit 1
  fi

  ensure_environment

  local destination="${LCOD_BIN_DIR}/${kernel_id}"
  if [[ -f "${destination}" && "${force}" != "true" ]]; then
    log_error "Kernel '${kernel_id}' already installed at ${destination} (use --force to overwrite)"
    exit 1
  fi

  mkdir -p "${LCOD_BIN_DIR}"
  cp "${source_path}" "${destination}"
  chmod +x "${destination}"
  clear_quarantine_if_needed "${destination}"

  config_add_or_update_kernel "${kernel_id}" "${version}" "${destination}"

  log_info "Kernel '${kernel_id}' installed at ${destination}"
  if [[ -n "${version}" ]]; then
    log_info "Recorded version ${version}"
  fi
  if [[ "${from_release}" == "true" ]]; then
    log_info "Source: ${asset_path}"
  fi

  if [[ -n "${cleanup_dir}" ]]; then
    rm -rf "${cleanup_dir}"
  fi

  update_kernel_update_cache "${kernel_id}" "${version}" "$(current_epoch)"
}

cmd_run() {
  ensure_environment

  local kernel_id=""
  local args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --kernel)
        kernel_id="${2:-}"
        shift 2 || true
        ;;
      -h|--help)
        cat <<'EOF'
Usage: lcod run [--kernel <id>] [--] <args...>

Executes the configured kernel runtime (defaulting to the one marked as default) and forwards the provided arguments.
EOF
        return 0
        ;;
      --)
        shift
        args+=("$@")
        break
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  if [[ -z "${kernel_id}" ]]; then
    kernel_id=$(config_get_default_kernel)
  fi

  if [[ -z "${kernel_id}" ]]; then
    log_error "No default kernel configured. Install one with 'lcod kernel install <id>' or pass --kernel explicitly."
    exit 1
  fi

  if ! config_kernel_exists "${kernel_id}"; then
    log_error "Kernel '${kernel_id}' is not registered. Install it first."
    exit 1
  fi

  auto_update_kernel_if_needed "${kernel_id}"

  local kernel_path
  kernel_path=$(config_get_kernel_path "${kernel_id}")
  if [[ -z "${kernel_path}" || ! -e "${kernel_path}" ]]; then
    log_error "Kernel binary for '${kernel_id}' not found at ${kernel_path}."
    exit 1
  fi

  local cmd
  local forward=()

  case "${kernel_path}" in
    *.jar)
      cmd="java"
      forward=(-jar "${kernel_path}")
      ;;
    *.mjs|*.cjs|*.js)
      cmd="node"
      forward=("${kernel_path}")
      ;;
    *.ps1)
      if command -v pwsh >/dev/null 2>&1; then
        cmd="pwsh"
      else
        cmd="powershell"
      fi
      forward=(-File "${kernel_path}")
      ;;
    *.bat|*.cmd)
      cmd="${kernel_path}"
      ;;
    *)
      cmd="${kernel_path}"
      ;;
  esac

  if [[ ${#args[@]} -gt 0 ]]; then
    forward+=("${args[@]}")
  fi

  exec "${cmd}" "${forward[@]}"
}

cmd_kernel_remove() {
  local kernel_id="${1:-}"
  if [[ -z "${kernel_id}" ]]; then
    log_error "Usage: lcod kernel remove <kernel-id>"
    exit 1
  fi

  ensure_environment

  if ! config_kernel_exists "${kernel_id}"; then
    log_warn "Kernel '${kernel_id}' not registered; nothing to remove."
    return 0
  fi

  local existing_path
  existing_path=$(config_get_kernel_path "${kernel_id}")

  if [[ -n "${existing_path}" && -f "${existing_path}" ]]; then
    if [[ "${existing_path}" == "${LCOD_BIN_DIR}/"* ]]; then
      rm -f "${existing_path}"
      log_info "Removed binary ${existing_path}"
    else
      log_warn "Skipping deletion of ${existing_path} (outside managed bin directory)."
    fi
  fi

  config_remove_kernel "${kernel_id}"
  log_info "Kernel '${kernel_id}' removed from manifest."
}

cmd_cache_clean() {
  ensure_environment
  if [[ -d "${LCOD_CACHE_DIR}" ]]; then
    rm -rf "${LCOD_CACHE_DIR:?}/"*
    log_info "Cache cleared."
  else
    log_info "Cache directory not present."
  fi
}

cmd_self_update() {
  ensure_environment
  log_info "Self-update placeholder. Will download latest release in future iteration."
  touch_update_stamp
}

main() {
  ensure_environment
  maybe_auto_update_cli

  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    help|-h|--help)
      print_help
      ;;
    version)
      cmd_version "$@"
      ;;
    kernel)
      local sub="${1:-}"
      shift || true
      case "${sub}" in
        ls)
          cmd_kernel_ls "$@"
          ;;
        install)
          cmd_kernel_install "$@"
          ;;
        remove|rm|delete)
          cmd_kernel_remove "$@"
          ;;
        default)
          cmd_kernel_default "$@"
          ;;
        *)
          log_error "Unknown kernel subcommand '${sub}'"
          exit 1
          ;;
      esac
      ;;
    run)
      cmd_run "$@"
      ;;
    cache)
      local sub="${1:-}"
      shift || true
      case "${sub}" in
        clean)
          cmd_cache_clean "$@"
          ;;
        *)
          log_error "Unknown cache subcommand '${sub}'"
          exit 1
          ;;
      esac
      ;;
    self-update)
      cmd_self_update "$@"
      ;;
    *)
      log_error "Unknown command '${cmd}'"
      print_help
      exit 1
      ;;
  esac
}

main "$@"
